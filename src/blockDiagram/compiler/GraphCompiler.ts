/**
 * Main graph compiler
 * Orchestrates the compilation of a block diagram to FV-1 assembly
 */

import { BlockGraph } from '../types/Graph.js';
import { BlockRegistry } from '../blocks/BlockRegistry.js';
import { TopologicalSort } from './TopologicalSort.js';
import { CodeGenerationContext } from '../types/CodeGenContext.js';

export interface CompilationStatistics {
    instructionsUsed: number;
    registersUsed: number;
    memoryUsed: number;
    blocksProcessed: number;
}

export interface CompilationResult {
    success: boolean;
    assembly?: string;
    statistics?: CompilationStatistics;
    errors?: string[];
    warnings?: string[];
}

export class GraphCompiler {
    private registry: BlockRegistry;
    private topologicalSort: TopologicalSort;
    
    constructor(registry: BlockRegistry) {
        this.registry = registry;
        this.topologicalSort = new TopologicalSort();
    }
    
    /**
     * Compile a block diagram to FV-1 assembly code
     */
    compile(graph: BlockGraph): CompilationResult {
        const errors: string[] = [];
        const warnings: string[] = [];
        
        // 1. Validate graph structure
        const validation = this.validateGraph(graph);
        if (!validation.valid) {
            return {
                success: false,
                errors: validation.errors
            };
        }
        if (validation.warnings) {
            warnings.push(...validation.warnings);
        }
        
        // 2. Topological sort to determine execution order
        const sortResult = this.topologicalSort.sort(graph);
        if (!sortResult.success) {
            return {
                success: false,
                errors: [sortResult.error || 'Failed to sort blocks']
            };
        }
        
        const executionOrder = sortResult.order!;
        
        // 3. Create code generation context
        const context = new CodeGenerationContext(graph);
        
        // 4. Generate code for each block in execution order
        const codeLines: string[] = [];
        
        // Header
        codeLines.push(';================================================================================');
        codeLines.push(`; ${graph.metadata.name}`);
        if (graph.metadata.description) {
            codeLines.push(`; ${graph.metadata.description}`);
        }
        if (graph.metadata.author) {
            codeLines.push(`; Author: ${graph.metadata.author}`);
        }
        codeLines.push('; Generated by FV-1 Block Diagram Editor');
        codeLines.push(';================================================================================');
        codeLines.push('');
        
        // Memory declarations
        const memoryBlocks = context.getMemoryBlocks();
        if (memoryBlocks.length > 0) {
            codeLines.push('; Memory allocations');
            for (const mem of memoryBlocks) {
                codeLines.push(`${mem.name}\tequ\t${mem.size}`);
            }
            codeLines.push('');
        }
        
        // Generate code for each block
        try {
            for (const blockId of executionOrder) {
                const block = graph.blocks.find(b => b.id === blockId);
                if (!block) {
                    continue;
                }
                
                const definition = this.registry.getBlock(block.type);
                if (!definition) {
                    errors.push(`Unknown block type: ${block.type}`);
                    continue;
                }
                
                // Generate block code
                const blockCode = definition.generateCode(context);
                codeLines.push(...blockCode);
            }
        } catch (error) {
            return {
                success: false,
                errors: [`Code generation failed: ${error}`]
            };
        }
        
        // 5. Count instructions (rough estimate)
        const instructions = codeLines.filter(line => {
            const trimmed = line.trim();
            return trimmed.length > 0 && 
                   !trimmed.startsWith(';') && 
                   !trimmed.includes('equ');
        }).length;
        
        // Check instruction limit
        if (instructions > 128) {
            errors.push(
                `Program uses ${instructions} instructions, but FV-1 maximum is 128. ` +
                'Reduce complexity or optimize blocks.'
            );
        } else if (instructions > 120) {
            warnings.push(
                `Program uses ${instructions}/128 instructions. ` +
                'Very close to limit!'
            );
        }
        
        // 6. Build statistics
        const statistics: CompilationStatistics = {
            instructionsUsed: instructions,
            registersUsed: context.getUsedRegisterCount(),
            memoryUsed: context.getUsedMemorySize(),
            blocksProcessed: executionOrder.length
        };
        
        // Return result
        if (errors.length > 0) {
            return {
                success: false,
                errors,
                warnings: warnings.length > 0 ? warnings : undefined
            };
        }
        
        return {
            success: true,
            assembly: codeLines.join('\n'),
            statistics,
            warnings: warnings.length > 0 ? warnings : undefined
        };
    }
    
    /**
     * Validate the graph structure
     */
    private validateGraph(graph: BlockGraph): { 
        valid: boolean; 
        errors?: string[]; 
        warnings?: string[] 
    } {
        const errors: string[] = [];
        const warnings: string[] = [];
        
        // Check for blocks
        if (graph.blocks.length === 0) {
            errors.push('Graph is empty - add some blocks first');
            return { valid: false, errors };
        }
        
        // Check for at least one output block
        const hasOutput = graph.blocks.some(b => 
            b.type.startsWith('output.')
        );
        if (!hasOutput) {
            errors.push('Graph must have at least one output block (DACL or DACR)');
        }
        
        // Check for at least one input block
        const hasInput = graph.blocks.some(b => 
            b.type.startsWith('input.')
        );
        if (!hasInput) {
            warnings.push('Graph has no input blocks - output will be silent');
        }
        
        // Validate each block's connections
        for (const block of graph.blocks) {
            const definition = this.registry.getBlock(block.type);
            if (!definition) {
                errors.push(`Unknown block type: ${block.type} (block ${block.id})`);
                continue;
            }
            
            // Check required inputs are connected
            for (const input of definition.inputs) {
                if (input.required) {
                    const hasConnection = graph.connections.some(
                        c => c.to.blockId === block.id && c.to.portId === input.id
                    );
                    if (!hasConnection) {
                        errors.push(
                            `Block '${definition.name}' (${block.id}) ` +
                            `requires input '${input.name}' to be connected`
                        );
                    }
                }
            }
        }
        
        // Validate connections
        for (const connection of graph.connections) {
            // Check source block exists
            const sourceBlock = graph.blocks.find(b => b.id === connection.from.blockId);
            if (!sourceBlock) {
                errors.push(`Connection references non-existent source block: ${connection.from.blockId}`);
                continue;
            }
            
            // Check dest block exists
            const destBlock = graph.blocks.find(b => b.id === connection.to.blockId);
            if (!destBlock) {
                errors.push(`Connection references non-existent destination block: ${connection.to.blockId}`);
                continue;
            }
            
            // Check ports exist
            const sourceDef = this.registry.getBlock(sourceBlock.type);
            const destDef = this.registry.getBlock(destBlock.type);
            
            if (sourceDef && !sourceDef.outputs.some(p => p.id === connection.from.portId)) {
                errors.push(
                    `Connection references non-existent output port '${connection.from.portId}' ` +
                    `on block ${connection.from.blockId}`
                );
            }
            
            if (destDef && !destDef.inputs.some(p => p.id === connection.to.portId)) {
                errors.push(
                    `Connection references non-existent input port '${connection.to.portId}' ` +
                    `on block ${connection.to.blockId}`
                );
            }
        }
        
        return {
            valid: errors.length === 0,
            errors: errors.length > 0 ? errors : undefined,
            warnings: warnings.length > 0 ? warnings : undefined
        };
    }
}
